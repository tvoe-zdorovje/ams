package by.anatolyloyko.ams.orm.util.generator.exposed

import by.anatolyloyko.ams.infrastructure.kotlin.alsoIf
import by.anatolyloyko.ams.infrastructure.kotlin.lowercaseFirstChar
import by.anatolyloyko.ams.infrastructure.kotlin.uppercaseFirstChar
import by.anatolyloyko.ams.orm.util.generator.SchemaGenerator
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import org.jetbrains.exposed.sql.Column
import org.jetbrains.exposed.sql.CustomFunction
import org.jetbrains.exposed.sql.QueryParameter
import org.jetbrains.exposed.sql.Table
import java.io.File
import java.nio.file.Paths

private const val MODULE_DESTINATION_DIRECTORY = "src/main/kotlin"

private const val KDOC = """
 *  ██████████████████████████ DO NOT MODIFY! █████████████████████████
 *  █                                             
 *  █                    It's an autogenerated file.
 *  █     To regenerate, execute:
 *  █ ./gradlew :%L:generateDatabaseSchema
 *  █
 *  ███████████████████████████████████████████████████████████████████

 Represents the %L %L in the database.
 
 Defines the structure to facilitate database operations using the Exposed library.
"""

private const val PRIMARY_KEY_PROPERTY_NAME = "primaryKey"

private const val ID_PROPERTY_NAME = "id"

private const val NULLABLE_INITIALIZER = "\n.nullable()"

private const val NAME_DELIMITER = "_"

/**
 * Abstract implementation of [SchemaGenerator] for generating Kotlin classes using the KotlinPoet library.
 *
 * The class relies on the KotlinPoet library
 * to generate the Kotlin code representing database tables and functions based on schema information,
 * and it provides the structure to define the schema lookup logic via the abstract method [lookupSchemas].
 *
 * This implementation first looks up schemas by their names,
 * then generates Kotlin files based on the retrieved schema information.
 *
 * @param pathToDestinationModule the path to the module where the Kotlin class files will be generated.
 * @param destinationPackage the package name in which the Kotlin class files will be generated.
 */
internal abstract class KotlinPoetSchemaGenerator(
    private val pathToDestinationModule: String,
    private val destinationPackage: String,
) : SchemaGenerator {
    /**
     * Generates Kotlin classes representing the structure of tables and functions in the provided schemas.
     *
     * This method looks up corresponding schema information for the given schema names,
     * and generates Kotlin classes for each schema. The method ensures that the list of schema names is not empty.
     *
     * @param schemaNames a list of schema names to generate Kotlin classes for.
     * @return a list of paths to the generated Kotlin class files.
     * @throws IllegalArgumentException if the `schemaNames` list is empty.
     *
     * @see lookupSchemas
     * @see generateSchema
     */
    override fun generate(schemaNames: Iterable<String>) =
        lookupSchemas(
            schemaNames
                .toList()
                .ifEmpty { throw IllegalArgumentException("Parameter 'schemaNames' must not be empty!") }
        )
            .forEach(::generateSchema)

    /**
     * Abstract method for looking up schema information by their names.
     *
     * This method is responsible for finding the schema details for the provided list of schema names.
     * The implementation of this method will vary depending on how schema information is retrieved
     * (e.g., querying the database or reading from a configuration file).
     *
     * @param schemaNames a list of schema names to look up.
     * @return a list of [SchemaInfo] objects containing the details of the requested schemas.
     */
    protected abstract fun lookupSchemas(schemaNames: List<String>): List<SchemaInfo>

    /**
     * Generates Kotlin files based on the provided schema information using the KotlinPoet library.
     *
     * @param schemaInfo an object containing the schema details.
     * @return a list of paths to the generated Kotlin files.
     */
    private fun generateSchema(schemaInfo: SchemaInfo) {
        val tableFileSpecs = schemaInfo.tables.map {
            buildTableFileSpec(schemaInfo.name, it)
        }

        val functionFileSpecs: List<FileSpec> = schemaInfo.functions.map {
            buildFunctionFileSpec(schemaInfo.name, it)
        }

        (tableFileSpecs + functionFileSpecs)
            .map { fileSpec ->
                fileSpec.writeTo(Paths.get(pathToDestinationModule, MODULE_DESTINATION_DIRECTORY))
            }
    }

    private fun buildTableFileSpec(
        schemaName: String,
        tableInfo: SchemaInfo.TableInfo
    ): FileSpec {
        val objectType = "table"
        val className = "${tableInfo.name.normalize(true)}${objectType.uppercaseFirstChar()}"

        return FileSpec
            .builder(
                packageName = "$destinationPackage.$schemaName.$objectType",
                fileName = className
            )
            .addType(
                TypeSpec
                    .objectBuilder(className)
                    .addModifiers(KModifier.INTERNAL)
                    .superclass(Table::class)
                    .addSuperclassConstructorParameter("%S", "$schemaName.${tableInfo.name}")
                    .addKdoc(objectType = objectType)
                    .suppress("MagicNumber")
                    .addProperties(
                        tableInfo
                            .columns
                            .map(::generatePropertySpec)
                    )
                    .addPrimarykey()
                    .build()
            )
            .build()
    }

    private fun buildFunctionFileSpec(
        schemaName: String,
        functionInfo: SchemaInfo.FunctionInfo
    ): FileSpec {
        val functionType = functionInfo.type
        val className = "${functionInfo.name.normalize(true)}${functionType.uppercaseFirstChar()}"

        return FileSpec
            .builder(
                packageName = "$destinationPackage.$schemaName.$functionType",
                fileName = className
            )
            .addType(
                TypeSpec
                    .classBuilder(className)
                    .addModifiers(KModifier.INTERNAL)
                    .superclass(CustomFunction::class.parameterizedBy(functionInfo.resultType.propertyType))
                    .primaryConstructor(
                        FunSpec
                            .constructorBuilder()
                            .apply {
                                functionInfo.arguments.forEach { (name, type) ->
                                    addParameter(
                                        name = name.normalize(),
                                        type = type.propertyType.asTypeName().copy(nullable = true)
                                    )
                                }
                            }
                            .build()
                    )
                    .addSuperclassConstructorParameter("\n\t%S", "$schemaName.${functionInfo.name}")
                    .addSuperclassConstructorParameter("\n\t%T()", functionInfo.resultType.exposedColumnType::class)
                    .apply {
                        functionInfo.arguments.forEach { (name, type) ->
                            addSuperclassConstructorParameter(
                                "\n\t%T(%L, %T().%L)",
                                QueryParameter::class,
                                name.normalize(),
                                type.exposedColumnType::class,
                                "apply { nullable = true }"
                            )
                        }
                        addSuperclassConstructorParameter("\n")
                    }
                    .addKdoc(objectType = functionType)
                    .suppress("MagicNumber", "ConstructorParameterNaming")
                    .build()
            )
            .build()
    }

    private fun generatePropertySpec(columnInfo: SchemaInfo.TableInfo.ColumnInfo): PropertySpec {
        val name = columnInfo.name
        val type = columnInfo.type
        val isPrecisedVarchar = type == DataType.varchar && columnInfo.varcharLength != null

        return PropertySpec
            .builder(
                name = columnInfo.name.normalize(),
                type = Column::class.parameterizedBy(type.propertyType)
            )
            .initializer(
                CodeBlock
                    .builder()
                    .alsoIf(isPrecisedVarchar) { it.add("$type(%S, %L)", name, columnInfo.varcharLength) }
                    .alsoIf(!isPrecisedVarchar) { it.add("$type(%S)", name) }
                    .alsoIf(columnInfo.isNullable) { it.add(NULLABLE_INITIALIZER) }
                    .build()
            )
            .build()
    }

    private fun TypeSpec.Builder.addKdoc(objectType: String) = this.addKdoc(
        KDOC,
        // a module name for the task invocation example
        pathToDestinationModule.substringAfterLast(File.separatorChar),
        // an object name (including a schema name)
        superclassConstructorParameters.first(),
        // an object type (table | function | procedure)
        objectType
    )

    private fun TypeSpec.Builder.suppress(vararg values: String) = this.addAnnotation(
        AnnotationSpec
            .builder(Suppress::class)
            .addMember("%L", values.joinToString { "\"$it\"" })
            .build()
    )

    private fun TypeSpec.Builder.addPrimarykey() = this.addProperty(
        PropertySpec
            .builder(
                name = PRIMARY_KEY_PROPERTY_NAME,
                type = Table.PrimaryKey::class
            )
            .addModifiers(KModifier.OVERRIDE)
            .initializer("%L(%L)", Table.PrimaryKey::class.simpleName, ID_PROPERTY_NAME)
            .build()
    )

    private fun String.normalize(capitalizeFirstChar: Boolean = false): String = split(NAME_DELIMITER)
        .joinToString(separator = "") { part ->
            part.replaceFirstChar {
                if (it.isLowerCase()) {
                    it.titlecase()
                } else {
                    it.toString()
                }
            }
        }
        .alsoIf(!capitalizeFirstChar) { return it.lowercaseFirstChar() }
}
